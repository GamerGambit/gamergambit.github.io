---
layout: post
title:  "K2 201"
date:   "2023-07-22"
categories: idk2
tags: unreal-engine k2
description: "Basic K2 Node"
---

In this article[?] we are going to be implementing a custom K2 node. The node is going to provide print functionality identicle to the existing `Print String` blueprint node with the addition of verbosity like you would find in `UE_LOG`.

# Before we get started
It's important to know that K2 nodes are only allowed in editor modules, not runtime modules. When a blueprint is compiled that contains your custom K2 node, `ExpandNode` is called and the result will be serialized as bytecode.If your project already contains an editor module you can use, feel free to skip the next section.

## Creating an Editor Module
Below are the files and contents you will need for your editor module. For more details on how to set up editor modules, read [this link](https://unrealcommunity.wiki/creating-an-editor-module-x64nt5g3)

{% highlight cs %}
using UnrealBuildTool;
using System.Collections.Generic;

public class {Project}EditorTarget : TargetRules
{
	public {Project}EditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		IncludeOrderVersion = EngineIncludeOrderVersion.Latest;
		ExtraModuleNames.AddRange(new string[] { "{Project}", "{Project}Editor" });
	}
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor.target.cs</cite></figcaption>

{% highlight cs %}
using UnrealBuildTool;

public class {Project}Editor : ModuleRules
{
    public {Project}Editor(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
        OverridePackageType = PackageOverrideType.GameUncookedOnly;

        PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });

        PrivateDependencyModuleNames.AddRange(new string[] {
            "BlueprintGraph"
        });
    }
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/{Project}Editor.build.cs</cite></figcaption>

{% highlight cpp %}
#pragma once

#include "Modules/ModuleManager.h"

class F{Project}Editor : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/{Project}Editor.h</cite></figcaption>

{% highlight cpp %}
#include "{Project}Editor.h"

IMPLEMENT_MODULE(F{Project}Editor, {Project}Editor);

void F{Project}Editor::StartupModule()
{
	//
}

void F{Project}Editor::ShutdownModule()
{
	//
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/{Project}Editor.cpp</cite></figcaption>

# The K2 Node
Now that we have a suitable editor module to use, we can make the node. The class stub itself is pretty simple, so here it is.

{% highlight cpp %}
#pragma once

#include "K2Node.h"

#include "K2Node_Print.generated.h"

UCLASS()
class UK2Node_Print : public UK2Node
{
	GENERATED_BODY()

public:
#pragma region UEdGraphNode
	virtual void AllocateDefaultPins() override;
	virtual FLinearColor GetNodeTitleColor() const override { return FLinearColor(1.0f, 0.1f, 1.0f); }
	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override { return FText::FromString("Print with Verbosity"); }
	virtual void ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph) override;
#pragma endregion // UEdGraphNode

#pragma region UK2Node
	virtual void GetMenuActions(class FBlueprintActionDatabaseRegistrar& ActionRegistrar) const override;
#pragma endregion // UK2Node
};
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/Classes/K2Node_Print.h</cite></figcaption>

{% highlight cpp %}
#include "K2Node_Print.h"

#include "BlueprintNodeSpawner.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "KismetCompiler.h"

void UK2Node_Print::AllocateDefaultPins()
{
	//
}

void UK2Node_Print::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);
}

void UK2Node_Print::GetMenuActions(class FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// actions get registered under specific object-keys; the idea is that 
	// actions might have to be updated (or deleted) if their object-key is  
	// mutated (or removed)... here we use the node's class (so if the node 
	// type disappears, then the action should go with it)
	UClass* ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first   
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the 
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/Private/K2Node_Print.cpp</cite></figcaption>

Theres a little bit to unpack here. We found out in the previous article what `AllocateDefaultPins`and `ExpandNode` do, so lets cover some of the new functions here.

## GetNodeTitleColor
As the function name suggests, this function is responsible for coloring the node. `FLinearColor` is normalized so `0` is black and `1` is white. For this node, we are going with a nice [hot pink color](https://www.colorhexa.com/ff19ff).

## GetNodeTitle
Another self-explanatory function, it sets the title of the node in the graph. You can expand this function further by using the provided `TitleType`, so you can display a different name in the right-click menu for example. This is how the Reroute Node works.

{% highlight cpp %}
// Copyright Epic Games, Inc. All Rights Reserved.
FText UK2Node_Knot::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	if (TitleType == ENodeTitleType::EditableTitle)
	{
		return FText::FromString(NodeComment);
	}
	else if (TitleType == ENodeTitleType::MenuTitle)
	{
		return LOCTEXT("KnotListTitle", "Add Reroute Node...");
	}
	else
	{
		return LOCTEXT("KnotTitle", "Reroute Node");
	}
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>Snippet from K2Node_Knot.hpp</cite></figcaption>

## GetMenuActions
This function is responsible for actually displaying your node in the right-click menu (Actions Menu) and making it spawn into the blueprint graph when you select it. The implementation shown is the minimum you need to get your now showing in the Actions Menu and spawning it into the graph. Why this isnt the default implementation in `UK2Node` we will never know.

## Out first node
Thats the basic implementation for our first K2 node. It does absolutely nothing but its ours and we made it.

<div class="row">
<div class="col-md" markdown="1">

![Timeline Node](/assets/img/print_actions.png)

</div>
<div class="col-md" markdown="1">

![Timeline Node Expanded](/assets/img/print_node.png)

</div>
</div>

# Allocating Pins
You might look at our node and realise that it looks weird; it's missing pins. The `Print String` node has a total of 8 pins: 2 execution pins, 1 string pin, 2 boolean pins, 1 linear color pin, 1 float pin, and 1 name pin. In order for our node to even come close to the usefulness of `Print String`, we will need to have at least those 8 pins with another pin for verbosity.

To create a pin all we need to do is call `CreatePin`, however if we call this function wherever we want, it might not behave how we want or expect. `AllocateDefaultPins` will ensure that the pin exists when the pin is re/created which is what we want in this case. `CreatePin` takes at least 3 parameters:
* Direction: Input or output (`EGPD_Input`/`EGPD_Output`)
* Category: Pin category of the pin (eg  boolean, float, name, string, object, etc) (`UEdGraphSchema_K2::PC_*`)
* Name: The name of this pin. Does not need to be unique but its a good idea. Unreal supplies some common names for pins with `UEdGraphSchema_K2::PN_*`

## Print String Pins
Now that we know what parameters we need to create a pin, lets take a look at `Print String` and add a `CreatePin` call for each:

![Print String Annotated](/assets/img/printstring_annotated.png)

{% highlight cpp %}
void UK2Node_Print::AllocateDefaultPins()
{
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, "InString");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, "bPrintToScreen");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, "bPrintToLog");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FLinearColor>::Get(), "TextColor");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, "Duration");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, "Name");
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/Private/K2Node_Print.cpp</cite></figcaption>

### CreatePin extra parameter
Earlier I said that `CreatePin` takes **at least** 3 parameters yet for `TextColor` we have 4 parameters: `Direction`, `Category`, `PinSubCategoryObject`, and `Name`. For fundamental blueprint types such as integer, bool, and float the `PinSubCategoryObject` parameter is not needed. In fact it's not even needed for complex types like enum, struct, and object. This additional parameter is called `PinSubCategoryObject` which essentially tells the pin which type of the category we are after. In the case of `PC_Struct`, we tell the pin *which* struct we want to accept. If we did not provide a subcategory object for `TextColor` the pin would accept any struct type which is not what we want.

## Verbosity Pin
Our new node looks good but its missing a pin for verbosity; the entire reason we are making this node in the first place. Should be simple enough right?
Yes, *sort of*. The problem with this particular case is that the enum we would use for verbosity (`ELogVerbosity`) is not exposed to blueprints, so we need to make our own enum which we will manually map to `ELogVerbosity` with a `switch` statement later on. Simple, right?

If we take a look at `ELogVerbosity` we will find all the verbosities we need. For simplicity, we will use only the valid verbosities in ours:

{% highlight cpp%}
UENUM()
enum class EPrintLogVerbosity: uint8
{
	Fatal,
	Error,
	Warning,
	Display,
	Log,
	Verbose,
	VeryVerbose
};
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/Classes/K2Node_Print.h</cite></figcaption>

Now all that's left is to add a pin to our node, similar to how we added the `TextColor` pin:

{% highlight cpp%}
void UK2Node_Print::AllocateDefaultPins()
{
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_String, "InString");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, StaticEnum<EPrintLogVerbosity>(), "InVerbosity"); //<-- Our shiny new verbosity pin
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, "bPrintToScreen");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Boolean, "bPrintToLog");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FLinearColor>::Get(), "TextColor");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, "Duration");
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, "Name");
}
{% endhighlight %}
<figcaption class="blockquote-footer"><cite>/Source/{Project}Editor/Private/K2Node_Print.cpp</cite></figcaption>

Just like that we have a neat looking `Print String with Verbosity` node that looks like it does what it says:

<div class="row">
<div class="col-md" markdown="1">

![Print with Verbosity](/assets/img/printv.png)

</div>
<div class="col-md" markdown="1">

![Print with Verbosity with expanded enum](/assets/img/printv_enumexpanded.png)

</div>
</div>